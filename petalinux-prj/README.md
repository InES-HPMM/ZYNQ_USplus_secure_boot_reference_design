# Tools and Environment

This section describes the tools and the environment used for the
implementation. All features were tested on a Mercury XU5 (ME-XU5-5EV-2I-D12E)
module mounted on a Mercury PE1 board (ME-PE1-300-W). To generate the bitstream
and configure the hardware Vivado 2019.2 was used. The official template from
Enclustra was used, which can be downloaded from their website . Further
configuration and generating the boot images were made with PetaLinux 2019.2.
The applications were manually compiled, although they can be directly
integrated into the PetaLinux process. Nevertheless, because it is often very
time consuming, the gnu-aarch64-none-linux-gcc compiler (9.2-2019.12) was used.
The operating system of the host computer was based on Ubuntu 18.04.

## PetaLinux-prj folder structure

| Folder/File name | Description |
|------------------|-------------|
| .PetaLinux | Contains specific files for PetaLinux. Do not edit any files in here. |
| generated_images | The most recent generated and approved .bin files are located in here. |
| project-spec | PetaLinux project configuration files. Most edits concerning the specific partitions are made in here. |
| uboot-scripts | Contains u-boot scripts to write images into the QSPI memory section 0x0-0x1000000 or 0x1000000-0x2000000. |
| .gitignore | .gitignore file generated by PetaLinux. |
| boot.bif | Boot image file. Contains information how the final image is packed. |
| config.project | PetaLinux specific file. generated by PetaLinux and does not need to be edited. |
| make_uboot_scrit.sh | Shell script to build the u-boot scripts. |
| moverootfs.sh | Shell script to move generated rootfs to /tftpboot/nfsroot if nfs is used. |
| package.sh | Shell script to generate a boot image using the boot.bif file. |

## PetaLinux project structure

A useful PetaLinux project structure description can be found in the Tools
Documentation and Reference Guise.

[Petalinux Tools Documentation Reference Guide (UG1144)](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_1/ug1144-petalinux-tools-reference-guide.pdf)

## PetaLinux or Yocto?

PetaLinux is the tool chain from Xilinx to create a Linux image for the Zynq
Ultrascale+. It is built upon Yocto, which is an-open source project, to
create Linux distributions for different platforms. Instead of using PetaLinux,
it is possible to use Yocto  for development on the Zynq Ultrascale+.

The advantage of Yocto is, it works for many platforms and therefore, the same
tools and workflow can be used for different platforms. Because Yocto is more
often used, it has a better documentation, more examples and more guides
available than for PetaLinux. 

However, there is also a disadvantage. Although Xilinx provides guides to work
with Yocto, it is not officially supported by Xilinx. If any problem occurs,
even if it is related to Yocto, Xilinx will not provide any support for it.
Xilinx maintains a forum for PetaLinux, where most questions are answered.
Further, guides and examples for Yocto are not as good maintained as for
PetaLinux and are sometimes out of date.

## Getting started

This section describes how to create the first project for a Mercury Board from
Enclustra. A description of how to install and use PetaLinux can be found in the
following user manuals and application notes from Xilinx. The following Guides
focuses on the specialities of the Mercury Board.

  - [Petalinux Tools Documentation Reference Guide (UG1144)](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_1/ug1144-petalinux-tools-reference-guide.pdf)
  - [PetaLinux Tools Documentation Command Line Reference Guide (UG1157)](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2019_1/ug1157-petalinux-tools-command-line-guide.pdf)

### Create Vivado project

If further adjustments to the hardware have to be made, it makes sense to create
a Vivado project as well. The user guide to the reference design from Enclustra 
describes how to create a Vivado project.

  - Mercury XU5 SoC Module Reference Design for Mercury+ PE1 Base Board User
    Manual 

### Export Hardware

After synthesizing the Vivado project, the hardware information and the
bitstream have to be exported. To export the hardware access

```
File->Export->Export Hardware...
```

in the menu bar. It is essential to check `Include bitstream` in the options
window, in order to use the export in PetaLinux.

### Create PetaLinux Project

In this case, none of the template board support packages from Xilinx will fit
the chip, and an exported hardware will be later imported to the project. Thus,
create a project with the `zynqMP` template.

```
petalinux-create --type project --template zynqMP --name <project-name>
```

**Attention**
Sometimes PetaLinux can not build the cloned project. In such a case simply
create anew project and then overwrite it with the project files from this repository.

### Import hardware to the PetaLinux project

This step is always necessary, after any changes in hardware. The new bitstream
has to be exported and imported to PetaLinux. During this work, no issues were
detected with the import. Though, since PetaLinux 2019.2 Xilinx introduced a new
file format for hardware description files. The new files have the ending `.xsa`,
instead of the older `.hdf`. However, older files can still be imported. If in
previous steps no hardware has been exported, the exported hardware in the
reference design from Enclustra  can be imported. For the board used in this
work the `.hdf` file can be found in this path:

```
Mercury_XU5_Reference_Design_for_Mercury_PE1_V6.2/SdkExport/system_top_5ev_2i.hdf
```

It is essential only to have one exported hardware file in the folder, else
PetaLinux will complain. Import the hardware description file to PetaLinux with
the following command.

```
petalinux-config --get-hw-description=<PATH-TO-FOLDER-CONTAINING-HDF-OR-XSA>
```

### Configure PetaLinux Project

After importing the hardware description, the first configuring window appears.
It can be exited by double-pressing the `ESC` key. The different components are
configured separately in PetaLinux. There are two ways to configure components.
If available, a `menuconfig` can be invoked, as seen after the hardware import, by typing:

```
petalinux-config -c <COMPONENT-NAME>
```

The different components with are:

  - `u-boot`
  - `kernel`
  - `rootfs` (default)

Other components can be configured by creating a configuration file.
These components are:

  - `pmufw`
  - `bootloader` — FSBL 
  - `device-tree`

### Build PetaLinux project

Likewise, to configuring, build individual components with the `-c <COMPONENT-NAME>` flag. To build
the whole project use:

```
petalinux-build
```

### Packaging the project

After building the project, all individual executables are generated
individually but are not bundled together in a boot-able image. To generate a
basic boot-able image use:

```
petalinux-package --boot --fsbl <FSBL-ELF> --fpga <BITSTREAM> --u-boot --pmufw <PMUFW-ELF>
```

With this image, the device will not boot securely. To generate an image for a
secure boot, read the following section.

# Secure Boot

The implementation of secure boot focuses mainly on packaging and settings in
the eFuse registers. Two implementations of secure boot are possible. By setting
the `ENC_ONLY` bit in the eFuse the “encryption only” secure boot process is activated.
This boot mode is limiting, because this mode only uses AES for authentication
and confidentiality. Additionally, the device can only use the AES master or
device key stored in the eFuse register. Therefore, the other secure boot mode
“root of trust” has been implemented. To activate the “root of trust” mode one
has to write the `RSA_EN` bits in the eFuse. For testing purposes, Xilinx provides a
feature to work with this secure boot mode, before writing the `RSA_EN` bits. In this
mode, everything works as expected, with authentication, but the authentication
of the PPK never happens. Instead, the bootloader skips this step and goes right
to the authentication process. Therefore, neither secure boot nor key revocation
works, because the checks between eFuse and the boot header are skipped.
Nevertheless, the chip is not limited to authenticated images. It can run any
images, as long as those secure boot bits are not set.

Too boot securely, the content of the boot-able image and the security features
of each partition have to be defined. Instead of packaging the image only using
the command above, which is very limited, an additional file is introduced. This
`.bif` file is a description file of the boot image. It defines:

  - The containing partitions
  - Where the partition is executed
  - If the partitions are encrypted, what key to use
  - If the partitions are authenticated, what key to use
  - Where and when partitions are loaded

A complete list and description of all definitions is available in the bootgen
User Guide . bootgen is the tool behind the `.bif` file. It is automatically
installed when installing PetaLinux. In case the bootgen tool has to be used
separately, it can be installed using the Vivado Design Suite Web installer .

## Authentication

The key and signature paths have to be included in order to generate images with
authentication. Thus, in the `.bif` file has to be declared, which key is used for
which partition. Because RSA is an asymmetric authentication method with public
and private keys, there are multiple possibilities to do so. The more
straightforward way, which we implemented, was by providing the secret keys. The
other possibility is by using only public keys. This possibility can be used to
protect the secret keys. The following code listing shows the settings when only
public keys are used.

``` objectivec
image : {
    /* Key revocation features */
    [auth_params] ppk_select=0; spk_select=spk-efuse; spk_id=0x00000000

    /* Define primary public key file */
    [ppkfile]primarypublickey.pem

    /* Define secondary public key file for the boot header*/
    [spkfile]secondarypublickey1.pem

    /* Define the signature file for the secondary public key */
    [spksignature]spk_signature.sig

    /* Define the signature file for the boot header and fsbl as they are together authenticated */
    [bhsignature]bh_signature.sig

    /* Define the signature file for the header table */
    [headersignature] header_signature.sig

    /* Enabling authentication and define signature file for individual images */
    [
    authentication    = rsa,
    spkfile           = secondarypublickey2.pem,
    presign           = signature2.sig,
    /* (Optional) Select a different spk_id and spk_id source */
    spk_select        = <spk-efuse/user-efuse>,
    spk_id            = 0x00000000
    ] image.bin
}
```

This way is more complicated than with secret keys because additionally, a
signature has to be provided. However, it is a more secure way because the
secret keys remain unrevealed. To generate the signatures and key files, use a
toolkit like openssl. The generated keys have to have a key length of 4096 bits.
A good systematic description is available in the bootgen documentation  in the
description about creating images using a hsm module, starting on page 73.

If the secret keys are available during the image creation, the `.bif` file looks a bit
simpler. Instead of defining public keys and signatures, only the secret keys
have to be defined. bootgen automatically generates signatures and public keys
in the process.

``` objectivec
image : {
    /* Key revocation features */
    [auth_params] ppk_select=0; spk_select=spk-efuse; spk_id=0x00000000

    /* Define primary secret key */
    [pskfile] primarysecretkey.pem

    /* Define secondary secret key for the boot header*/
    [sskfile] secondarysecretkey1.pem

    /* Enabling authentication and define a secondary secret key for individual images */
    [
    authentication    = rsa,
    sskfile           = secondarysecretkey2.pem,
    /* (Optional) Select a different spk_id and spk_id source */
    spk_select        = <spk-efuse/user-efuse>,
    spk_id            = 0x00000000
    ] image.bin
}
```

In this example, for each partition, a different key has been used. The
additional parameter

```
[fsbl_config] bh_auth_enable
```

can be set, to test authentication and secure boot without blowing the `RSA_EN`
eFuse. With this parameter set, authentication will be enabled. However, the PPK
will not be checked with the hash stored in the eFuse, as well as the `SPK_IDs`.
If neither the `RSA_EN` eFuse nor this parameter is set, nothing of the boot
image will be authenticated.

**Important**
The boot header and the fsbl need to have the same key defined. They usually are
authenticated separately, but we noticed during testing, that the authentication
throws an error, if two separate keys are defined.

### Generate Keys for RSA 

In both cases, at some point, keys have to be generated. Xilinx provides a way
of using bootgen.

```
openssl genrsa -out key.pem 4096
```

With this way, bootgen will generate secret RSA keys in the defined location.
The location must exist, else bootgen will throw a segmentation fault. This
command is only usable if a primary and one secondary key is used. In cases,
which more secondary keys are used, bootgen will not generate the other keys.
Thus, the second approach with openssl is easier.

Important is to generate a key with the key length of 4096 bits.

### Generate PPK Hash

To be able to write the hash from the PPK to the eFuse, it first has to be
generated. Thus, the bootgen tool also provides a feature to generate the hash
automatically.

```
bootgen -efuseppkbits efuseppkhash.txt -arch zynqmp -w -o test.bin -image boot.bif
```

Bootgen stores the hash in the defined file. In this example `efuseppkhash.txt`.

## Encryption

As AES is a symmetrical method, it is much easier to implement. However, it has
the disadvantage that the key files have to be available, for the generation of
the image. The operational key method reduces the amount, in which the device
key is used. While with the normal method, all the images would be decrypted
using the device key, with the operational key method, only a small encrypted
part of the boot header is decrypted with the device key. All following
partitions are decrypted using their own key, saved in the previous partition.
To further reduce the risk of a key leakage, the rolling key method can also be
implemented. The following code listing shows a basic `.bif` file, implementing
encryption with the operational key method and the rolling key method for the
`longimage.bit` file. More information about file attributes can be found in the
bootgen User Guide.

``` objectivec
image : {
    /* Define source of device key */
    [keysrc_encryption] BBRAM_red_key

    /* Further options */
    [fsbl_config] opt_key

    /* Enabling encryption and defining key file for individual images */
    [
    encryption    = AES,
    AESkeyfile    = AESkeyfile1.nky
    ] image.bin

    /* (Optional) Enabling rolling key method for big image partition */
    [
    encryption    = AES,
    /* Attention!: the keyfile has to have the number of keys required for the amount of blocks */
    AESkeyfile    = AESkyfile2.nky,
    /* Define length and amount of blocks */
    blocks        = 2014(2);2048(2);8192(2);4096(*)
    ] longimage.bit
  }
```

### Generate Keys for AES

To generate keys for AES nothing has to be especially done. When the bootgen
command runs, it automatically generates new keys, if it does not find the
defined ones. Only the part name has to be specified with the option, in
addition to the usual options. The part name can be anything. The follwing code
listing shows that bootgen writes the part name into the key file. The key files
may vary. This key file has been generated with the `boot.bif` file from this
repository.

```
Device       <partname>;

  Key 0        50C0F949817F0A00DD3A66117599936D7A14BAB349BB546E1CBBAD32F69278D3;
  IV 0         A2E411F57D6045FE506B994F;

  Key 1        83283F2FCA0F1A2643A8D62811CBB2DB6184C330CF9E926818FA098556ECBBD5;
  IV 1         C28E78DAE84F9BF415FD142D;

  Key Opt      96EEBD73F10EB683E8F4028D609AB86AA90E8D19920AB55BF507878C6DEE3E86;
```


The first key is the device key, which has to be loaded, to the eFuse or BBRAM.
This key should be the same across all generated key files. Also, the according
iv should be the same. The second key is the individual key for each partition.
This key and the iv are different from partition to partition. The last key is
the operational key. This key and iv are also identical on all key files.
